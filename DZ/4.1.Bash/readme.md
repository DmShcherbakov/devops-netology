# 4.1. Командная оболочка Bash: Практические навыки - Дмитрий Щербаков
### 1. Есть скрипт:
```commandline
a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
```
### Какие значения переменным c,d,e будут присвоены? Почему?
| Переменная	 |Значение	|Обоснование|
|-------------|---|---|
| `c`         |`a+b`|Без указания символа `$` a и b воспринимаются просто как символы, соответственно переменной `c` присваивается текстовая строка `a+b`|
|`d`|`1+2`|Здесть в выражении идет обращение к переменным `$a` и `$b`, но т.к. они явным образом не задекларированы как численные, то и воспринимаются как текст, поэтому в переменную `d` попала строка со значениями переменных `a` и `b`|
|`e`|`3`|Двойные круглые скобки позволяют осуществлять арифмитические вычисления внутри Bash, поэтому результатом выражения станет сумма численных значений переменных|

### 2. На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:
```commandline
while ((1==1)
do
	curl https://localhost:4757
	if (($? != 0))
	then
		date >> curl.log
	fi
done
```
Исправленная версия скрипта будет выглядеть следующим образом (кроме добавления возможности выхода и недостающей скобки, для уменьшения "мусора" в журнале, добавлена задержка в 1 секунду после каждой итерации):
```commandline
#!/usr/bin/env bash
while ((1==1))
do
	curl https://localhost:4757
	if (($? != 0))
	then
            date >> curl.log
            sleep 1
	else
	    break
	fi
done
```
### Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. Проверять доступность необходимо пять раз для каждого узла.
Вариант скрипта:
```commandline
#!/usr/bin/env bash
ip1=192.168.0.1
ip2=173.194.222.113
ip3=87.250.250.242
for i in {1..5}
do
  echo ------ $(date) ------ >> test.log
  for j in {$ip1,$ip2,$ip3}
    do
      echo "******** $j ********" >> test.log
      nmap -p 80 $j >> test.log
    done
  echo ===================== >> test.log
done
exit 0
```

<code>[Ознакомиться с содержимым файла test.log.](./test.log) </code>

### 3. Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается.
Мой вариант скрипта:
```commandline
#!/usr/bin/env bash
ip1=192.168.0.1
ip2=173.194.222.113
ip3=87.250.250.242
i=0
while (($i==0))
do
    for j in {$ip1,$ip2,$ip3}
    do
      nmap -sP --host-timeout 1 $j | grep "Host is up" 1>/dev/null
      if [[ "$?" = "1" ]]
      then
        echo "$(date) $j is not alive" >> test1.log
        i=1
      fi
    done
done
exit 0
```

Содержимое файла test1.log после блокировки адреса 173.194.222.113 файрволом:
```commandline
$ cat test1.log 
Вт 14 дек 2021 20:27:09 MSK 173.194.222.113 is not alive
```
