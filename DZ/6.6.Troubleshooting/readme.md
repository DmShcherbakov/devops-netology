# 6.6. Troubleshooting - Дмитрий Щербаков

## Задача 1
### Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.
### Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
### Вы как инженер поддержки решили произвести данную операцию:
### - напишите список операций, которые вы будете производить для остановки запроса пользователя
Для того, чтобы остановить запрос пользователя, необходимо сначала узнать идентификатор процесса при помощи db.currentOp(), после чего воспользоваться методом db.killOp(<opId>) с идентификатором операции, полученным на предыдущем шаге.
### - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
Как вариант борьбы с долгими запросами, можно воспользоваться методом maxTimeMS(), который задает предел времени выполнения операции.
Например:
```commandline
db.location.find( { "town": { "$regex": "(Pine Lumber)",
                              "$options": 'i' } } ).maxTimeMS(30)
```

## Задача 2
### Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.
### Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
### При масштабировании сервиса до N реплик вы увидели, что:
### - сначала рост отношения записанных значений к истекшим
### - Redis блокирует операции записи
### Как вы думаете, в чем может быть проблема?
Проблема может быть вызвана тем, что в режиме активного алгоритма очистки устаревших ключей, Redis запускает процедуру раз в 100мс, удаляя по 20 ключей (200 ключей в секунду). В случае роста количества ключей, срок жизни которых истекает в тот самый момент, когда происходит очистка, мы можем столкнуться с ситуацией, когда ключи не успевают удаляться. Если количество просроченных ключей превышает 25%, Redis блокирует операции до того момента, когда соотношение просроченных и актуальных ключей снизится до указанной величины (25%).

## Задача 3
### Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
```commandline
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
### Как вы думаете, почему это начало происходить и как локализовать проблему?
Судя по ошибке и описанию (ошибка стала возникать при росте количества записей, а не была зафиксирована изначально), проблема заключается в том, что клиент не успевает получить ответ на запрос в отведенное время. С целью локализации, следует воспользоваться профайлингом, чтобы понять с какой скоростью выполняются те или иные запросы. 
### Какие пути решения данной проблемы вы можете предложить?
Наиболее простым решением является увеличение значения переменной net_read_timeout (по-умолчанию, она установлена в 30с) в соответствии с данными, полученными при анализе времени обработки запросов.
Однако, следует также обратить внимание на структуру базы данных. Возможно, удастся достичь снижения времени выполнения запросов при оптимизации индексов или с помощью шардирования таблиц.

## Задача 4
### Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
### После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
```commandline
postmaster invoked oom-killer
```
### Как вы думаете, что происходит?
В данном случае происходит исчерпание системной памяти, что приводит к старту процесса Out-Of-Memory Killer, предназначенного для завершения процессов, занимающих большой объем памяти, во избежание краха системы.
### Как бы вы решили данную проблему?
Одним из вариантов решения проблемы является увеличение объема памяти сервера.
В качестве других мер можно рассмотреть следующие действия:
- задать для переменной vm.overcommit_memory значение 2, тогда ядро не будет резервировать больше памяти, чем указано в параметре overcommit_ratio;
- отключить OOM-killer (например, командой ```sudo -s sysctl -w vm.oom-kill = 0```). Не рекомендуется.

